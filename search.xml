<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》总结]]></title>
    <url>%2F2019%2F06%2F12%2Fprofessional-js%2F</url>
    <content type="text"><![CDATA[终于把《JavaScript 高级程序设计》看完(假装看完，其实跳过了几章 0.0)了，颇有一些心得，总结一下。首先就是，这本书的内容，大而全。Js的各方面都有介绍，内容详细，涉及面广。其次，有些内容相对较旧了。毕竟 第三版 是2012年3月发行的，当时 ES6 还没定稿，所以这本书后面有些内容，和现在会稍有不同，主要是最后几章。接下来，是看完本书后的部分总结。心得JS加载JS会阻塞 DOM 的加载和渲染。defer ：立即加载JS，但不执行，待DOM渲染完成后再执行JS。多个 defer 按顺序执行，但实际上不一定，所以建议只有1个JS使用 defer 参数。XHTML 下需写成 defer=&quot;defer&quot; 。async ：异步加载JS(不阻塞DOM)，加载完后执行JS(此时会阻塞DOM)，执行完后继续加载/渲染DOM。不按顺序执行。XHTML 下需写成 async=&quot;async&quot; 。类型检测基本类型 ：typeof 。包括 undefined、number、boolean、string ，外加 function 。引用类型 ：instanceof 。包括 Object、Array、Date、Regexp 。检测 Object 永远返回 true ，检测 基本类型 永远返回 false 。1234567// 基本类型var str = "string";alert(typeof(str)); // string// 引用类型var person = &#123;&#125;;alert(person instanceof Object); // true垃圾收集垃圾收集主要有 标记清除 和 引用计数 两种方式，其中 标记清除 是现在的主流方式。标记清除 ：现在5大主流浏览器使用的方式。当一个变量进入一个环境(比如函数)时，将该变量标记为 进入环境 ，当该变量离开环境(比如函数)时，标记该变量为 离开环境 。垃圾收集器会给存储在内存上的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后垃圾收集器销毁那些带标记的值并回收它们所占用的空间。不同浏览器垃圾收集的时间间隔不同。引用计数 ：含义是：跟踪记录每一个值被引用的次数。当一个值被一个变量引用时，该值的 引用次数 +1，又被另一个变量引用时，引用次数 继续+1，取消引用也类似。当 引用次数 为0后，当 垃圾收集器 下次运行时，就会释放这些 引用次数 为0的值所占用的内存。这个方法有个严重的 bug ，当循环引用的时候，引用次数就永远不会为0，垃圾收集器也就 永远不会回收这些循环引用的值/变量 。可以使用 variable = null 这样的方式 手动清除引用 。函数call，apply ：第一个参数是 this 的值，同时也是这个函数的环境/作用域；第二个参数是传入函数的参数；利用第一个参数，可以改变函数执行的环境/作用域，这是最常用且非常巧妙的一种用法！！；123456789101112age = 10;var obj = &#123; name: 'Jack', age: 18&#125;;var fun1 = function(num) &#123; alert(this.age + num);&#125;// 传入nullfun1.apply(null, [1]); // 非严格模式下，this为window；严格模式下，this为null，然后会报错。// 传入thisfun1.apply(this, [1]); // this为window，全局作用域，返回11// 传入objfun1.apply(obj, [1]); // this为obj对象，obj作用域，返回19arguments.callee() ：指向当前函数，一般 递归函数 中使用较多。严格模式 下不能使用。1234567891011121314151617// 阶乘函数function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125;//可以改写成以下写法，减少函数的执行与函数名的耦合function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); // 此行改动 &#125;&#125;arguments.caller() ：指向调用该函数的函数，返回调用函数的源代码。严格模式 下不能使用。1234567function outer() &#123; inner();&#125;function inner() &#123; alert(arguments.callee.caller);&#125;outer(); // 返回outer函数的源代码JSONJSON类型简单值 ：包含 字符串、数值、布尔值 和 null ( undefined 会自动被忽略 )。JSON字符串 和 JS字符串 的区别：JSON字符串 必须使用双引号，JS字符串 可以使用 双引号 和 单引号 ；对象 ：JSON对象 和 JS对象 的区别：JSON对象 的属性名必须使用 双引号 ，JS对象 的属性名 可以加双引号也可以不加引号 ；JSON对象 没有声明变量；JSON对象 末尾没有 分号 ；数组 ：JSON数组 和 JS数组 的区别：JSON数组 没有声明变量；JSON数组 末尾没有 分号 ；JSON.stringify(obj, para1, para2) ：JS对象 =&gt; JSON字符串 ；para1 ：可选，用于过滤结果，可以是数组或函数；数组 ：只返回数组中的 key ；function(key, value) ：重新格式化每个 key 的值；para2 ：可选，用于指定缩进，可以是数值或字符串；数值：缩进 n 个空格，最大长度为10；字符串：缩进字符串，最大长度为10；JSON.parse(str, para1) ：JSON字符串 =&gt; JS对象 ；para1 ：可选，和 JSON.stringify 的 para1 中的 fucntion 类似，用于还原结果，是一个函数；function(key, value) ：重新格式化每个 key 的值；AjaxAjax 是一种局部刷新页面的技术，它向服务器请求数据而无需卸载页面，只局部刷新页面。原生写法123var xhr = new XMLHttpRequest();xhr.open(type, url, isAsync);xhr.send(data);说明：type ：post 、get 等；url ：请求的 url ，get 请求时查询字符串参数必须使用 encodeURIComponent() 进行编码；isAsync ：是否异步。jQuery 默认为 true ；data ：一定要填，为空的话写 null ；可以使用表单形式给服务器传数据(结果是键值对，而不是string字符串)，使用方法如下：123456789101112// 初始化// ...// 方法1var form = document.getElementById("user-info");var data = new FormData(form);// 方法2var data = new FormData();data.append("key1", "value1");data.append("key2", "value2");// 发送给服务器xhr.send(data);更多信息 ：Page 575；HTTP头信息 ：可以自定义信息在头部，供服务器读取；超时设定 ：xhr.timeout 、xhr.ontimeout=function(){} ；进度事件 ：load 、progress ；跨域介绍CORS(Cross-Origin-Resource Sharing) 定义了跨域时，浏览器与服务器该如何通信。CORS 的基本思路浏览器 =&gt; 服务器 的 请求头 中添加：Origin: url ；服务器 =&gt; 浏览器 的 响应头 中添加： Access-Control-Allow-Origin: url ；这2个 url 必须一致；IE8 的跨域使用 XDR(XDomainRequest) 对象来创建实例(替代 XMLHttpRequest 对象)；123var xdr = new XDomainRequest();xdr.open(type, url, isAsync);xdr.send(data);其他主流浏览器的跨域原生支持 ：直接使用 XMLHttpRequest 对象创建实例即可；其他跨域技术图像Ping ：单向，浏览器 =&gt; 服务器 ；JSONP ：双向，把 url 添加到 &lt;script&gt; 标签中，然后 &lt;script&gt; 标签添加到 document.body 内；Comet ：长轮询 和 流；服务器发送事件 ：SSE ；WebSocket用于在一个单独的持久连接上提供 全双工、双向通信 。原生写法123456789var socket = new WebSocket(url);socket.send(data);socket.onmessage = function(event) &#123; var data = event.data;&#125;;// 其他3个事件socket.onopen = function()&#123;&#125;;socket.onerror = function()&#123;&#125;;socket.onclose = function()&#123;&#125;;说明url ：传输协议为 ws:// 和 wss:// ，分别对应 未加密 和 加密 的协议；send ：data 只能是 字符串 ;onmessage ：服务器 返回的数据存放在 event.data 中；优缺点优点 ：能够双向通信，服务器 能主动推送数据给 浏览器 ；传输数据小，占用资源少，速度快。因为相比较 http/https 的传输协议，ws/wss 的请求头更小，所以每次传输数据，“无效”的请求头数据会更少，对于高频率的请求效果更明显；缺点 ：h5 新增的功能，对于某些旧浏览器并不支持；需要使用不同的 web服务器(传输协议为 ws/wss ) ；高级技巧高级函数安全的类型检测instanceof 检测时，必须是在同一个全局作用域下才有效(比如一个页面包含多个frame时，在 非构造函数页面 检测会返回false)；利用 原生XX 的构造函数名与全局作用域无关，因此使用 toString() 就能够保证返回一致的值，所以可以创建以下函数；123456789101112// 检测数组function isArray(value) &#123; return Object.prototype.toString.call(value) == "[object Array]";&#125;// 检测函数function isFunction(value) &#123; return Object.prototype.toString.call(value) == "[object Function]";&#125;// 检测正则表达式function isRegExp(value) &#123; return Object.prototype.toString.call(value) == "[object RegExp]";&#125;作用域安全的构造函数当使用构造函数创建对象时，忘记使用 new 的情况下；123456789function Person(name, age, job) &#123; if (this instanceof Person) &#123; this.name = name; this.age = age; this.job = job &#125; else &#123; return new Person(name, age, job); &#125;&#125;原理：使用 new 的情况下，this 指向的是 new 出来的新对象；未使用 new 的情况下，this 指向的是 全局对象window ；惰性载入函数在某些 if 判断的语句中，如果第一次怎样，后面每次都会这样，针对这种情况，可以使用 惰性载入函数 ，即 if里重写原方法，这样后面执行是就不用判断了；惰性载入函数 有两种写法：第一种是：函数被调用时再处理函数：第二种是：声明函数时就指定适当的函数：1234567891011// 原函数function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined") &#123; //... return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error("No XHR object available."); &#125;&#125;1234567891011121314151617// 第一种：函数被调用时再处理函数function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; createXHR = function()&#123; // 改变1 return new XMLHttpRequest(); &#125; &#125; else if (typeof ActiveXObject != "undefined") &#123; createXHR = function() &#123; // 改变2 //... return new ActiveXObject(arguments.callee.activeXString); &#125; &#125; else &#123; createXHR = function() &#123; // 改变3 throw new Error("No XHR object available.") &#125; &#125;&#125;1234567891011121314151617// 第二种：声明函数时就指定适当的函数var createXHR = (function() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return function() &#123; // 改变1 return new XMLHttpRequest(); &#125; &#125; else if (typeof ActiveXObject != "undefined") &#123; return function() &#123; // 改变2 // ... return new ActiveXObject(arguments.callee.activeXString); &#125; &#125; else &#123; return function() &#123; // 改变3 throw new Error("No XHR object available.") &#125; &#125;&#125;)(); // 改变4函数绑定函数绑定 要创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数；来看下面这个例子：12345678910111213var handler = &#123; message: "Event handler", handlerClick: function() &#123; alert(this.message); &#125;&#125;;var btn = document.getElementById("my-btn");// 返回undefinedEventUtil.addHandler(btn, "click", handler.handlerClick);// 返回Event handler, // 传入作为this值的对象，和 call，apply 类似EventUtil.addHandler(btn, "click", handler.handlerClick.bind(handler));函数柯里化用于创建已经设置好了一个或多个参数的函数；函数柯里化 的基本方法和 函数绑定 是一样的，都是使用一个闭包返回一个函数；两者的区别在于：当函数被调用时，返回的函数还需要设置一些传入的参数；来看下面的例子：123456789// 函数柯里化 定义函数function curry(fn) &#123; var args = Array.prototype.slice.call(arguments, 1); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;&#125;1234567// 函数柯里化 使用方法1// 超出参数自动忽略function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); // 81234567// 函数柯里化 使用方法2// 超出参数自动忽略function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5, 13, 2);alert(curriedAdd()); // 18防篡改对象注意：一旦把对象定义为防篡改，就不可撤销了 。不可扩展对象不能添加属性和方法，可删除和修改；使用 Object.preventExtensions(obj) 把 obj对象 修改为 不可扩展对象 ；密封的对象不能添加和删除属性和方法，但可修改；使用 Object.seal(obj) 把 obj对象 修改为 密封的对象 ；冻结的对象既不可扩展，又是冻结的。即不可新增、修改、删除属性和方法；使用 Object.freeze(obj) 把 obj对象 修改为 冻结的对象 ；高级定时器setTimeout 和 setInterval() 并不是 过xx毫秒后执行函数 ，而是 过xx毫秒后把函数代码添加到代码队列，在浏览器空闲时，将按队列顺序依次执行队列中的代码 。重复的定时器使用 setInterval() 时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这确保了队列中的最小时间间隔为指定间隔；当这种 重复定时器 有两个问题：(1)某些间隔会被跳过；(2)多个定时器的代码执行之间的间隔可能会比预期的小；为了解决这种问题，可以使用如下模式的 链式setTimeout()调用 ；1234setTimeout(function()&#123; // 处理中 setTimeout(arguments.callee, interval);&#125;, interval);Yielding Processos当某个循环占用了大量时间，如果该循环满足 1无需同步完成，2无需按顺序完成 ，则可使用一种叫做 数组分块 的技术，小块小块的处理数组，通常每次一小块；基本思路：为要处理的数组创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器；看下面这个例子：1234567891011// 思路setTimeout(function()&#123; // 取出下一个项目并处理 var item = array.shift(); process(item); //若还有条目，再设置另一个定时器 if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125;&#125;, 100)12345678910111213141516171819// 实际例子function chunk(array, process, context) &#123; setTimeout(function() &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100);&#125;var data = [12,123,23,234,1234,323,444,555,666,777];function printValue(item) &#123; var div = document.getElementById("myDiv"); div.innerHTML += item + "&lt;br&gt;";&#125;chunk(data, printValue);函数节流浏览器中某些操作(比如DOM)非常耗资源，高频率的进行这种操作可能会让浏览器崩溃。为了解决这个问题，可以使用定时器对该函数进行 节流 ；函数节流 背后的思路是：某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数时，会创建一个定时器，在指定的时间间隔后再执行函数；第二次调用时，会先清除前一次的定时器，并设置另外一个，然后重复前面的步骤；来看下面的例子：1234567// 思路function throttle(method, context) &#123; clearTimeout(method.tId); var method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100)&#125;12345// 未节流前写法，高频率的更新可能导致浏览器崩溃window.onresize = function() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;;123456789// 节流写法function resizeDiv() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;window.onresize = function() &#123; throttle(resizeDiv);&#125;自定义事件事件 是一种叫做 观察者 的设计模式，这是一种创建松散耦合代码的技术；观察者模式 由 主体 和 观察者 两部分组成；主体 ：发布事件；观察者 ：订阅事件，观察主体；Cookie服务器 生成并返回给 浏览器 的；绑定在特定域名下，只在绑定的域名下有效；(针对域名) 只要有的话，浏览器每次发数据给 服务器 ，一定会带上已经存在的 cookie ；未设定有效期的 cookie ，浏览器关闭后即失效，设定有效期的 cookie，手动删除或到期前，一直有效；最佳实践优化DOM在 JavaScript 各个方面中，DOM 毫无疑问是最慢的一部分。当往页面添加多个 &lt;li&gt; 元素时，每添加一次都要进行一次 现场更新，即页面要进行一次 重排重绘 ，性能损失非常大。最小化更新现场使用 文档片段 来构建DOM结构，接着将其添加到 List 元素中，这样只会进行一次 现场更新 ；12345678910var list = document.getElementById("myList"), fragment = document.createDocumentFragment(), item, i;for (i=0;i&lt;10;i++) &#123; item = document.createElement("li"); fragment.appendChild(item); item.appendChild(document.createTextNode("Item" + i));&#125;list.appendChild(fragment);使用 innerHTML创建 DOM 节点到另一种方法(前一种是 createElement 、appendChild 之类的)；对于小的 DOM 节点更改，两种方法效率差不多，然而对于大的 DOM 节点的更改，innerHTML 要比前一种快的多，因为只进行一次 现场更新 ；1234567var list = document.getElementById("myList"), html = "", i;for (i=0;i&lt;10;i++) &#123; html += "&lt;li&gt;Item" + i + "&lt;/li&gt;";&#125;list.innerHTML = html;使用事件代理利用 事件冒泡 ，在文档级别附加事件处理程序，这样可以处理整个页面的事件；注意 HTMLCollection任何时候要访问 HTMLCollection ，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很大；最小化访问 HTMLCollection 的次数可以极大的改进脚本的性能；优化 HTMLCollection 最重要的地方就是循环了；以下情况会返回 HTMLCollection 集合：进行了对 getElementsByTagName 的调用 ；获取了元素的 ChildNodes 属性 ；获取了元素的 attributes 属性 ；访问了特殊的集合，比如 document.forms、document.images 等 ；来看下面的例子：1234567891011121314151617// 优化前var images = document.getElementsByTagName("img"), i, len;for(i=0, len=images.length;i&lt;len;i++) &#123; //...&#125;// 优化后var images = document.getElementsByTagName("img"), image, i, len;for(i=0, len=images.length;i&lt;len;i++) &#123; image = images[i]; //...&#125;部署压缩 ：压缩分两部分，即 文件压缩 和 HTTP压缩 。文件压缩 ：把开发环境等文件( js、css 等)压缩，然后部署到服务器上；删除额外的空白，包括换行；删除所有注释；缩短变量名；HTTP压缩 ：服务器对传输给浏览器的代码进行压缩(服务器要进行配置)；浏览器对接收的资源进行解压缩，目前五大 Web浏览器都支持解压缩；；可以节省传输的数据，减少带宽消耗，加快响应速度；原理 ：一个指定了文件 使用了给定格式 进行了压缩的HTTP头 包含在了服务器响应中。接着浏览器会查看该 HTTP头确定文件是否已被压缩，然后使用合适的格式进行解压缩；新APIrequestAnimationFrame()早期动画循环；Page Visiblity APIdocument.hidden ：查看页面是否隐藏的布尔值。页面隐藏包括在后台标签页中或最小化浏览器；document.visibilityState ：表示下列4个可能状态的值：页面在后台标签中或浏览器最小化；页面在前台标签页中；实际的标签页已经隐藏，但用户可以看到页面的预览(比如win7鼠标移到任务栏的图标上看到的预览)；页面在屏幕外执行预渲染处理；visibilitychange 事件：文档从可见变为不可见，或从不可见变为可见时触发；Geolocation API地理定位 API；navigator.geolocation 对象；getCurrentPosition ：获取当前位置；watchPosition ：跟踪用户位置，与定时调用 getCurrentPosition 效果一样；clearWatch ：取消跟踪用户位置；File API能够在浏览器端读取本地文件的信息(文件名称，类型，大小，修改时间，文件内容等)；使用 &lt;input type=&quot;file&quot;&gt; 元素，返回对象的 files 属性；FileReader 类型var reader = new FileReader() ；readAsText(file, encoding) ：以纯文本形式读取文件，数据保存在 result 属性中；readAsDataURL(file) ：读取文件并将文件以 URI 的形式保存在 result 属性中；对象 URL引用保存在 File 或 Blob 中数据的 URL；window.URL.createObjectURL(file) ：获取 file 的URL；Web 计时window.performance ：获取页面的所有度量信息(即时间相关信息)；Web WorkersJavaScript 是单线程的；让 JavaScript 在后台运行，类似开了一个后台线程；来看下面的例子：1234567891011121314var worker = new Worker("stufftodo.js");// 这行代码会让浏览器下载js，但只有 worker接收到消息才会执行js代码// 使用 postMessage() 给 workder发送消息，可以是字符串或对象worker.postMessage("start! ");// worker返回到数据保存在 event.data 中worker.onmessage = function(event) &#123; var data = event.data; //...&#125;;worker.onerror = function(event) &#123; &#125;;// 立即停止 workder 到工作worker.terminate();跳过的章节其中有几章没看跳过了，有些是已经熟悉的，有些是优先级不高暂时跳过了，以后有时间了再补上吧～跳过的章节有：第8章：BOM；第9章：客户端检测；第10～12章：DOM；第13章：事件；第14章：表单；第15章：Canvas；第18章：JS与XML；第19章：E4X；严格模式有关 严格模式 与 非严格模式 的区别，请看下篇文章。点我查看]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 中的Flex]]></title>
    <url>%2F2019%2F05%2F31%2Fflex%2F</url>
    <content type="text"><![CDATA[CSS3 引入了一种新的布局模式————弹性盒子。引入弹性盒子的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。简介弹性盒子由 弹性容器(Flex container) 和 弹性子元素(Flex item) 组成。弹性容器 通过设置 display 的值为 flex 或 flex-inline ，将其定义为 弹性容器 。弹性容器 内包含一个或多个 弹性子元素 。弹性容器 外和 弹性子元素 内都是正常渲染，弹性盒子 只定义了 弹性子元素 如何在 弹性容器 内的布局。Flex 即为 弹性布局。设置为 Flex 布局之后，子元素 的 float、clear 和 vertical-align 属性将失效。接下来，介绍 Flex 常用的几个属性。常用属性flex-directionflex-direction ：弹性子元素 在 弹性容器 内 水平方向 上的排列规则。注意，这很重要：flex-direction 方向不同( row ，column )，会导致其他6个 flex 属性( flex-wrap，felx-flow，justify-content，align-content，align-items，align-self )的方向也不同！！后面6个 flex 属性的例子中，flex-direction 都为 row 。如果 flex-direction 改成 column ，会导致方向与现在的例子相反。即 水平xx 的都会变成 垂直xx ，而 垂直xx 的会变成 水平xx 。主要有以下几个值：row、row-reverse、column、column-reverse、initial、inherit 。row默认值 ；水平方向，从左往右正常排列。row-reverse水平方向，从右往左排列。column垂直方向，从上往下排列。column-reverse垂直方向，从下往上排列。initial设置改属性为它的默认值。inherit从父元素继承该属性。flex-wrapflex-wrap ：规定 弹性子元素 是一行还是多行显示在 弹性盒子 内。即 弹性子元素 是否换行。主要有以下几个值：nowrap、wrap、wrap-reverse、initial、inherit 。nowrap默认值 ； 弹性子元素 不换行，宽度会改变(压缩)。wrap弹性子元素 换行，宽度不会改变。wrap-reverse弹性子元素 换行，宽度不会改变，且从右往左排序。initial设置该属性为它的默认值。inherit从父元素继承该属性。flex-flowflex-flow ：flex-direction 和 flex-wrap 的组合，第一个参数为 flex-direction ，第二个参数为 flex-wrap 。row-reverse wrap反向排序，且换行。justify-contentjustify-content ：弹性子元素 关于 弹性盒子 垂直轴，在水平方向上的分布规则。主要有以下几个值：flex-start、flex-end、center、space-between、space-around、initial、inherit 。flex-start默认值 ；不拆分，紧贴 弹性容器 的左边框。flex-end不拆分，紧贴 弹性容器 的右边框。center不拆分，在 弹性容器 内居中显示。space-between拆分，分别紧贴 弹性容器 的左、右边框， 弹性子元素 之间由 空白 分隔。space-around拆分，每个 弹性子元素 由宽度相同的 空白 围绕。所以 弹性子元素到边框 的距离是 弹性子元素到弹性子元素 距离到一半。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-contentalign-content ：弹性子元素 关于 弹性盒子 水平轴，在垂直方向上的分布规则。主要有以下几个值：stretch、flex-start、flex-end、center、space-between、space-around、initial、inherit 。stretch ：默认值 ；拆分，弹性子元素 被拉伸以适应 弹性容器 。flex-start不拆分，弹性子元素 紧贴 弹性容器 的上边框。flex-end不拆分，弹性子元素 紧贴 弹性容器 的下边框。center不拆分，在 弹性容器 内居中显示。space-between拆分，分别紧贴 弹性容器 的上、下边框，弹性子元素 之间由 空白 分隔。space-around拆分，每个 弹性子元素 由宽度相同的 空白 围绕。所以 弹性子元素到边框 的距离是 弹性子元素到弹性子元素 距离到一半。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-itemsalign-items ：设置 弹性容器 内的 所有 的 弹性子元素 的对齐方式。主要有以下几个值：stretch、flex-start、flex-end、center、baseline、initial、inheritstretch默认值 ；拉伸 弹性子元素 以适应 弹性容器 。flex-start弹性子元素 向上对齐 弹性容器 。flex-end弹性子元素 向下对齐 弹性容器 。center弹性子元素 居中对齐 弹性容器 。baseline弹性子元素 对齐 弹性容器 的基线(基本等效于 flex-start )。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-selfalign-items ：设置 弹性容器 内的 单个 弹性子元素 的对齐方式。主要有以下几个值：auto、stretch、flex-start、flex-end、center、baseline、initial、inherit 。auto默认值 ；继承它的父容器 (弹性容器) 的 align-items 属性，如果没有父容器则该值为 stretch 。stretch拉伸 弹性子元素 以适应 弹性容器 。flex-start弹性子元素 向上对齐 弹性容器 。flex-end弹性子元素 向下对齐 弹性容器 。center弹性子元素 居中对齐 弹性容器 。baseline弹性子元素 对齐 弹性容器 的基线(基本等效于 flex-start )。initial设置该属性为它的默认值。inherit从父元素继承该属性。参考链接css display:flex 属性CSS flex 属性CSS3 弹性盒子(Flex Box)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入url之后...]]></title>
    <url>%2F2019%2F05%2F25%2Fafter-input-url%2F</url>
    <content type="text"><![CDATA[最近找工作，发现面试官都会问一个问题：在浏览器输入url之后，会发生什么？那么，在浏览器输入url之后，到底会发生什么呢？接下来，我们一起学习一下 ~主要过程当我们在浏览器地址栏输入url之后，主要会经过下面几个步骤：域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后，发起http请求 –&gt; 服务器响应http请求，发送html代码给浏览器 –&gt; (默认)服务器发送html代码后，发起4次挥手，断开TCP请求 –&gt; 浏览器渲染页面1. 域名解析域名解析，又叫 DNS解析。用于把地址栏的URL解析成服务器的IP地址，进而访问服务器。域名解析按优先级，会有以下几种情况：查询浏览器缓存 ：浏览器会缓存之前拿到的DNS 2-30分钟时间，如果没有找到，继续下一种情况；查询系统缓存 ：检查 hosts 文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像一个本地的数据库，如果找到就可以直接获取目标主机的IP地址了。如果没找到，继续下一种情况；查询路由器缓存 ：路由器有自己的DNS缓存，可能包含了需要查询的内容。如果没有，继续下一种情况；查询ISP DNS 缓存 ：ISP服务商的DNS缓存（本地服务器缓存），那里可能有相关的内容。如果还没有，继续下一种情况；递归查询 ：从 根域名服务器 –&gt; 顶级域名服务器 –&gt; 权限域名服务器 –&gt; 得到服务器IP ；举个(ISP+递归查询)例子，浏览器发起一个DNS的系统调用，首先会先向本地配置的首选DNS服务器(一般是电信运营商提供的，也可以使用像Google提供的DNS服务器)发起域名解析请求。运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则由运营商的DNS代我们的浏览器发起迭代的DNS解析请求。它首先会找一个 根域的DNS的IP地址 ，找到 根域 的地址后，就会向其发起请求(请问 www.linux178.com 这个域名的IP地址是多少啊？ )，根域 发现这是一个 顶级域com域 的一个域名，就告诉运营商的DNS我不知道这个域名的IP地址，但我知道 com域 的IP地址，你可以去问它，于是运营商的DNS就得到了 com域 的IP地址，又向 com域 的DNS地址发起了请求(请问 www.linux178.com 这个域名的IP地址是多少啊？)，com域 这台服务器告诉运营商DNS，我不知道 www.linux178.com 这个域名的IP地址，但我知道 linxu178.com 这个域的IP地址，你可以去问它，于是运营商的DNS又向 linux178.com 这个域的DNS地址(这个一般就是由域名注册商提供的，像万网、新网等)发送请求(请问 www.linux178.com 这个域名的IP地址是多少啊？)，这个时候 linux178.com域 的DNS服务器一查，诶，果然在我这里，于是就把找到的结果返回给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 www.linux178.com 这个域名的IP地址了，之后再返回给浏览器，浏览器就得到要访问域名的IP地址了。2. TCP的三次握手第一次握手 ：Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN=1 表示这是一个请求连接或连接接受报文，同时表示这个接受报不能携带数据，seq=x 表示Client自己的初始序号(seq=0 就代表这是第0号包)，这时候Client进入 syn_sent ，表示客户端等待服务器的响应；第二次握手 ：Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的 SYN 和 ACK 都置1，ack=x+1 表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到(ack=1 其实就是 ack=0+1，也就是期望客户端的第1个包)，seq=y 表示Server自己的初始序号(seq=0 就代表这是服务器这边发出的第0号包)。这时服务器进入 syn_rcvd 状态，表示服务器已经收到Client的连接请求，等待Client的确认；第三次握手 ：Client收到确认后还需要再次发送确认，同时携带要发送给Server的数据。ACK=1 表示确认号 ack=y+1 有效(代表收到服务器的第1个包)，Client自己的序号seq=x+1(表示这就是我的第一个包，相对于第0个包来说的)，一旦收到Client的确认后，这个TCP连接就进入了 Established 状态，就可以发起http请求了。为什么要3次握手为了防止已失效的连接请求报文突然又传送到了服务器，进而产生错误。举个例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达server。这本来是一个早已失效的报文段，但server收到此报文段后，误认为这是client再出发出的一个新的连接请求。于是就像client发出确认报文段，同意建立连接。假设不采用 三次握手 ，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的连接已经建立了，并一直在等待client发来数据。这样，server的很多资源就白白浪费了。采用 三次握手 的方法就可以防止上述现象的发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。3. 传输数据HTTP请求报文一个HTTP请求报文由 请求行(request line) ，请求头部(header) ，空行 ，请求数据 4个部分组成，下图给出了请求报文的一般格式。请求行请求行分为三个部分：请求方法 ，请求地址 和 协议版本 。请求方法HTTP/1.1 定义的请求方法有8中：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE 。最常用的两种是 GET 和 POST ，如果是 RESTful 接口的话一般会用到 GET、POST、DELETE、PUT 。请求地址URL：统一资源定位符，是一种资源位置的抽象唯一识别方法。组成如下(端口和路径有时可以省略) ：GET 请求时，有时会带参数。协议版本协议版本的格式为：HTTP/主版本号.次版本号 ，常用的有 HTTP/1.0 和 HTTP/1.1 。请求头部请求头部为请求报文添加了一些附加信息，由 名/值 对组成，每行一对，名和值之间用冒号分隔。常见请求头如下：请求头部的最后会有一个 空行 ，表示请求头部结束，接下来为请求数据。这一行非常重要，必不可少。请求数据可选部分，比如 GET 请求就没有请求数据。下面是一个 POST 方法的请求报文：123456789101112POST /index.php HTTP/1.1 //请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 //请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded //空行username=aa&amp;password=1234 //请求数据HTTP响应报文HTTP响应报文主要由 状态行 ，响应头部 ，空行 和 响应数据 4个部分组成。下图给出了响应报文的一般格式。状态行由3部分组成，分别为：协议版本 ，状态码 ，状态码描述 。其中 协议版本 和请求报文一致，状态码描述 是对状态码的简单描述，所以这里只介绍 状态码 。状态码状态码 为3位数字。1xx ：指示信息——表示请求已接收，继续处理。2xx ：成功——表示请求已被成功接收、理解、接受。3xx ：重定向——表示要完成请求必须进行进一步的操作。4xx ：客户端错误——请求有语法错误或请求无法实现。5xx ：服务器端错误——服务器未能实现合法的请求。下面列举几个常见的：响应头部与 请求头部 类似，为响应报文添加一些附加的信息。常见的 响应头部 如下：响应数据用于存放需要返回给客户端的数据信息。下面是一个响应报文的实例：12345678910111213141516171819202122HTTP/1.1 200 OK //状态行Date: Sun, 17 Mar 2013 08:12:54 GMT //响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8 //空行&lt;html&gt; 响应数据&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;4. TCP的四次挥手默认情况下的TCP连接，在服务器发送一次html数据给浏览器后，服务器就会执行 四次挥手 以 断开TCP连接 ，除了下面这种情况：持久连接 ：只要任意一端没有明确的提出断开连接，则保持TCP连接状态。在 请求首部字段 中设置 Connection:keep-alive 即表示使用了持久连接。注意 ：主机1可以是 客户端，也可以是 服务器端 ；默认情况下，主机1是 客户端，即 客户端主动断开连接 的情况 ；若 服务器端 主动断开连接，则主机1是 服务器端 ；过程描述 ：主机1 进程发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u(等于前面已经传送过来的数据的最后一个字节的序号加1)，此时，主机1 进入 FIN-WAIT-1(终止等待1) 状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。主机2 收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并带上自己的序列号seq=v，此时，主机2就进入了 CLOSE-WAIT(关闭等待) 状态。主机2通知高层的应用程序，主机1 向 主机2 的方向就释放了，这时候处于半关闭状态，即 主机1 已经没有数据要发送了，但是 主机2 若发送数据，主机1 仍然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。主机1 收到 主机2 的确认请求后，此时，主机1 就进入 FIN-WAIT-2(终止等待2) 状态，等待 主机2 发送连接释放报文(在这之前还需要接受 主机2 发送的最后的数据)。主机2 将最后的数据发送完毕后，就向 主机1 发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，主机2 很可能又发送了一些数据，假定此时的序列号为seq=w，此时，主机2 就进入了 LAST-ACK(最后确认) 状态，等待 主机1 的确认。主机1 收到 主机2 的连接释放报文后了，比如发出确认，ACK=1，ack=w+1，而自己的序列号seq=u+1，此时，主机1 就进入了 TIME-WAIT(时间等待) 状态。注意此时TCP链接还没有释放，必须经过 2MSL(最长报文段寿命) 的时间后，当 主机1 撤销相应的TCB后，才进入 CLOSED 状态。主机2 只要接收到了 主机1 发出的确认，就立即进入 CLOSED 状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，主机2 结束TCP连接的时间要比 主机1 早一些。为什么要四次挥手因为三次握手时只是建立一个连接，之后才传递数据，在握手时是没有数据传输的，所以3次即可。而挥手时，主机1 停止向 主机2 传输数据后，主机2 会立刻响应 主机1，先回一个ACK报文，告诉 主机1，”你发的FIN报文我收到了，但只有等我 主机2 的所有报文都发送完毕后，我才能发送FIN报文”，所以挥手的时候 主机2 要分两步，所以挥手需要四次。为什么要等待 2MSL因为网络可能不稳定，最后一个 ACK报文有可能会丢失，所以，TIME-WAIT 状态就是用来重发可能丢失的 ACK报文(第四步的报文)。在四次挥手的过程中，主机2 在 LAST-ACK(最后确认) 状态时，如果没接收到了 主机1 发来的 ACK报文，则不断发送FIN片段。所以 主机1 不能立即关闭，它必须确认 主机2 接收到了该 ACK之后，才关闭连接。所以，主机1 会设置一个计时器，等待 2MSL的时间，如果再次收到FIN，说明之前发送的ACK没有传到 主机2，于是会重新发一个ACK给 主机2；如果等待 2MSL后没有收到FIN，说明 主机2 已收到ACK且已关闭，于是 主机1 也关闭，TCP连接结束。5. 渲染HTML页面客户端拿到服务器传输过来的文件后，找到 HTML 和 MIME 文件，通过 MIME 文件，浏览器知道要用页面渲染引擎来处理 HTML 文件。页面渲染主要有以下几个步骤：1. 解析html源码，创建一个DOM树在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。2. 解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM首先会忽略非法的CSS代码，然后按 浏览器默认设置——用户设置——外链样式——内联样式——style样式 的顺序进行渲染。3. 利用DOM和CSSOM构建一个渲染树（rendering tree）渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 HTML标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一行在渲染树中都是一个独立的节点。渲染树中的每一个节点都存储有对应的css属性。4. 浏览器根据渲染树，直接把页面绘制到屏幕上注意点JS和图片会阻塞 DOM 的加载和渲染。CSS不会阻塞 DOM 的加载，但会阻塞 DOM 的渲染(即浏览器控制台可以打印 DOM 节点了，但页面还是空白，没有渲染)。CSS会阻塞JS的加载和执行。加载JS时，添加 defer 参数，脚本会立即下载但不执行，在 DOM 加载完成后再执行。多个 defer 的脚本会按顺序执行。加载JS时，添加 async参数，脚本会异步加载再执行，执行的时候还是会阻塞 DOM 的加载。多个 async 的脚本不会按顺序执行。实际情况下，有时候多个 defer 时加载完后不一定会按顺序执行，所以建议，尽量合并成一个JS再使用 defer。关于 defer 和 async ，可以查看下图：参考链接1. 一次完整的HTTP请求过程2. 在浏览器输入URL并按回车后都发生了什么?3. 一次完整的HTTP请求过程4. 服务端主动终止连接的情况分析5. TCP的三次握手和四次挥手理解及面试题（很全面）6. defer和async的区别]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈浏览器内核]]></title>
    <url>%2F2019%2F05%2F23%2Fbrowser-kernel%2F</url>
    <content type="text"><![CDATA[内核简介一个完整的浏览器包含浏览器内核和浏览器外壳(shell)，浏览器核心––––内核分为两部分：渲染引擎 和 js引擎 。由于js引擎越来越独立，所以现在说的浏览器内核一般指 渲染引擎 。渲染引擎 ：解析DOM文档和CSS规则并将内容和样式显示到浏览器中。也叫 排版引擎 ，我们常说的浏览器内核主要指的就是 渲染引擎 。js引擎 ：解析和执行JS脚本的模块，如 V8引擎，JavaScriptCore 等。5 大主流浏览器(按时间顺序)IE 浏览器IE 是微软其下的浏览器，IE4~IE11 使用的都是 Trident 内核。Windows10 发布后，IE 将其内置浏览器命名为 Edge，使用新内核 EdgeHTML 。IE 从版本11开始，初步支持 WebGL 技术。IE8 的js引擎是 jscript ，IE9开始使用 Chakra ，这两个版本差别很大，Chakra 无论是速度还是标准化方面都很出色。Edge的JS引擎是 Chakra。Opera 浏览器Opera 是挪威 Opera Software ASA 公司其下的浏览器。1995年，Opera 公司发布第一版 Opera 浏览器，并使用 Presto 内核。2016年奇虎360和昆仑万维收购了 Opera 浏览器，并改用当时 Google 开源的 webkit 内核。之后 Opera 又跟随 Google 将浏览器内核改为 Blink 。Safari 浏览器Safari 是 Apple 公司自研的浏览器，主要用于 Apple 自身的产品。第二次浏览器大战也是从苹果公司发布 Safari 开始的。2003年，苹果公司在苹果手机上开发 Safari 浏览器，利用自己得天独厚的手机市场份额使 Safari 浏览器迅速成为世界主流浏览器。Safari 是最早使用 webkit 内核的浏览器，后来升级为 webkit2 内核，也是现在苹果默认的浏览器。Safari 的JS引擎是 JavaScriptCore 。Firefox 浏览器Firefox 是 Mozilla 公司旗下的浏览器，也就是 网景 公司后来的浏览器。网景被收购后，网景人员创办了 Mozilla 基金会，这是一个非营利性的组织，他们在2004年推出自己的浏览器 Firefox。Firefox 采用 Gecko 内核。Firefox 的JS引擎是 SpiderMonkey 。Gecko 是一个开源的项目，代码完全公开，因此受到很多人的青睐。Chrome 浏览器Chrome 是 Google 公司的浏览器。Chrome 最开始使用 webkit 分支出的 Chromium 内核，后来升级为 Blink 内核。Chrome 的JS引擎是 V8 。浏览器与JS引擎5 大内核Trident 内核也就是俗称的 IE内核 。Trident 内核迭代列表使用该内核的浏览器有：IE浏览器，多核浏览器。Presto(Opera前内核)(已废弃)Opera12.17及更早版本曾使用此内核，现已停止开发并废弃。Opera在2013年2月宣布放弃 Prosto，转而跟随 Chrome 使用 webkit 的分支 Chromium 引擎作为其核心。在 Chrome 与 2013年推出 Blink 核心后，Opera 也紧跟随其脚步使用 Blink 核心。Webkit 内核苹果公司研发的内核，后来升级为 webkit2。webkit内核包括：WebCore渲染引擎 和 JavaScriptCore解析引擎，均是从 KDE 的 KHTML 和 KJS 衍生而来的。2008年，Google 发布了 Chrome 浏览器，浏览器使用的内核叫做 Chromium 。Chromium fork 自开源引擎 Webkit ，Google 还研发了自己的JS引擎，即 V8引擎 ，极大的提高了 JavaScript 的运行速度。使用该内核的浏览器有：Safari，Android 默认浏览器，多核浏览器。Gecko 内核Netscape6 开始采用的内核，后来的 Mozilla Firefox 也采用了相同的内核。使用该内核的浏览器有：Mozilla Firefox，Mozilla SeaMonkey，Flock(早期版本)，K-Meleon 。Blink 内核2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 是一个由 Google 和 Opera Software 开发的浏览器 渲染引擎，Google 计划将这个渲染引擎作为 Chromium 计划的一部分。这一渲染引擎是开源引擎 WebKit 中WebCore 组件的一个分支，并且在 Chrome（28及往后版本）、Opera（15及往后版本）和 Yandex 浏览器中使用此外，Mozilla 与三星也达成合作协议开发”下一代”浏览器渲染引擎Servo。使用该内核的浏览器：Chrome，Opera，多核浏览器。补充：什么是 Chromium 计划Chromium 是 Google 为发展自家的浏览器 Google Chrome（以下简称Chrome）而开启的计划，所以 Chromium 相当于 Chrome 的工程版或称实验版（尽管Chrome自身也有β版阶段），新功能会率先在 Chromium 上实现，待验证后才会应用在 Chrome 上，故 Chrome 的功能会相对落后但较稳定。所以，Chromium 和 Chrome 都是浏览器，Chromium 是开发版本，相比起 Chrome 更新速度快很多，有时数个小时就有一个新版本，不过普通人一般用 Chrome 就可以了。补充：为什么要搞一个新的 Blink 内核Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎。后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。EdgeHTML 内核Windows10后，IE内置浏览器 Edge 使用的内核。JS引擎为 Chakra 。使用该内核的浏览器：Edge。国内其他浏览器上面说到的5大主流浏览器(IE，Edge，Opera，Safari，Firefox，Chrome)，都是单核浏览器。相比较，国内很多浏览器则是双核或多核。即由1个 Trident + N个其他核心 组成的。常见的国内浏览器核心如下：360安全浏览器（1.0-5.0为 Trident，6.0为 Trident+Webkit ，7.0为 Trident+Blink ）360极速浏览器（7.5之前为 Trident+Webkit ，7.5为 Trident+Blink）猎豹安全浏览器（1.0-4.2版本为 Trident+Webkit，4.3及以后版本为 Trident+Blink）傲游浏览器（傲游1.x、2.x为 Trident，3.x为 Trident+Webkit）世界之窗浏览器（最初为 Trident，2013年采用 Trident+Chromium）搜狗高速浏览器（1.x为 Trident，2.0及以后版本为 Trident+Webkit）UC浏览器（ Blink+Trident）对于多核浏览器，Trident 指 兼容模式，而 其他内核 指 高速浏览模式 。最后参考文章：1. 浏览器内核-渲染引擎、js引擎2. 五大主流浏览器与四大内核3. 聊聊浏览器内核]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个Linux命令]]></title>
    <url>%2F2019%2F05%2F16%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[最近在学一个系列，每天一个 Linux 命令由于之前的笔记是写在 旧版博客 上的所以这里就不重新整理一份了，hahaha ~直接，传送门(๑•̀ㅂ•́)و✧]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 hexo 的一次踩坑之旅]]></title>
    <url>%2F2019%2F05%2F14%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[关于 hexo 的一次踩坑之旅。之前一直是在自己搭的网站写博客，markdown写好后用编辑器转成 html 格式，然后直接扔上去。emmmmm… 巨丑。后来决定弄个漂亮点的博客，研究了下，决定用 hexo + github 来部署。看完文档感觉挺简单，结果花了几天时间才弄好，中间也碰到几个坑，记录一下。npm 权限问题因为之前安装 node 的时候自动安装了 npm ， 然后 Mac 下 npm 是默认安装在 /usr/local/ 路径下的，而该路径下很多目录和文件时 只读的 ，然后在安装 hexo 的时候，会报权限错误；12// 此处会报权限错误npm install -g hexo-cli解决方法网上找了一下，主要有四种解决方法：方法一为当前用户添加 npm安装目录 下所有文件的写权限。1sudo chown -R (whoami)(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;注意 ：如果路径是 /usr/local/ 的话不推荐这种方式，因为改权限会弄乱系统的权限，以后可能导致奇怪的错误(比如无法跟当前系统的其他用户共享)。方法二把 npm 卸载，并安装在一个有读写权限的路径下；推荐 ~/.npm-global 路径下；1.新建一个全局安装的路径；1mkdir ~/.npm-global2.配置 npm 使用新的路径；1npm config set prefix '~/.npm-global'3.打开或者新建 ~/.profile ，加入下面一行；1export PATH=~/.npm-global/bin:$PATH4.重新启动终端；1source ~/.profile5.测试：安装一个全局包试试12345npm install -g jslint[luncher@localhost aaa]$ ls ~/.npm-global/bin/jshint[luncher@localhost aaa]$方法三(推荐)使用 nvm 。nvm 可以在一台电脑上管理不同版本的 node，并且使用 nvm 安装 npm 后，npm 默认的安装路径是有读写权限的，也就是说，以后 npm 安装任何包都不用再使用 sudo 参数了。官网的解决方案：https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally；这里有个细节要注意：如果你本地已经安装了npm，你得先把本地的npm卸载，再安装nvm，再使用nvm安装npm；1.卸载已安装到全局的 node/npmnode 命令在 /usr/local/bin/node，npm 命令在 /usr/local/lib/node_modules/npm 下；查看已经安装的全局模块，以便卸载后再按不同的 node 版本重新安装；1npm ls -g --depth=0123sudo rm -rf /usr/local/lib/node_modules #删除全局 node_modules 目录sudo rm /usr/local/bin/node #删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep "../lib/node_modules/" | awk '&#123;print $9&#125;'| xargs rm #删除全局 node 模块注册的软链2.安装 nvm1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash方法四借助第三方工具安装 nodemac 系统借助 brew 安装 node1brew install nodecentos 系统借助 yum 安装 node1yum install node部署分支问题由于 hexo 部署(hexo d) 的原理是，把站点上的所有静态文件删除，并把本地待部署的全部静态站点文件(/public/目录下) push 到远程库上，即完全覆盖；所以 hexo 官方文档有这样一句话 建议使用 master 作为写作分支，新建一个 public 分支作为发布分支。在按照这样创建分支后，发现网站打不开，然后在 github pages 的文档里看到这样几句话：Reponsitory 必须以 username.github.io 命令，这个 username 为 github 的账户名，网站部署成功后，使用 https://username.github.io 进行访问；必须使用 master 分支管理网站静态文件。注意这句话，必须使用 master 分支。emmmmm….. 就是这么坑。所以，github的建议是：使用 master 作为发布分支，使用 hexo 作为写作分支。Hexo 的使用Hexo 的使用流程一般如下：官方文档1.安装 hexo1npm install -g hexo-cli2.创建 项目123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install3.新建 文章1hexo new [layout] &lt;title&gt;4.生成静态文件123hexo g// orhexo generate5.本地预览123hexo s// or hexo server6.部署到服务器123hexo d// or hexo deploy关于主题主题的使用很简单，以下几个步骤即可：1.clone 主题到本地12cd your_blog_dirgit clone https://github.com/DIYgod/hexo-theme-sagiri.git themes/sagiri2.修改 hexo 配置文件使用主题12## Themes: https://hexo.io/themes/theme: sagiri3.修改 主题配置文件，进行个性化设置1// 路径为：your_blog_dir/themes/sagiri/_config.yml推荐主题搜集了一些比较好看的主题：sagiri ：https://diygod.meMaterial X ：https://xaoxuu.comInside ：https://blog.oniuo.comNext ：https://blog.tolvyou.cn旧版博客最后，就是巨丑的旧版博客了…….]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搬家啦]]></title>
    <url>%2F2019%2F05%2F13%2FMigrate-Blog%2F</url>
    <content type="text"><![CDATA[博客搬家啦新博客使用 hexo + github pages 来搭建关于旧博客，对，就是巨丑的那个 ~~点我！点我就能看 ….(づ｡◕‿‿◕｡)づ————————– 分 割 线 ————————–补充一下由于旧博客不是用 博客框架 ( Hexo，Jekyll，Wordpress )搭建的所以很多文章不是用 markdown 写的，部分用 markdown 写的文章也由于内容太长然后，迁移起来就比较麻烦…o(╯□╰)o所以，就直接给个链接代替了..hahaha ~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
